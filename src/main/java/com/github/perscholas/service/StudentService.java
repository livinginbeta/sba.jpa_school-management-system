package com.github.perscholas.service;

import com.github.perscholas.DatabaseConnection;
import com.github.perscholas.dao.StudentDao;
import com.github.perscholas.model.CourseInterface;
import com.github.perscholas.model.Student;
import com.github.perscholas.model.StudentInterface;
import com.github.perscholas.utils.IOConsole;
import org.junit.Assert;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;

// TODO - Implement respective DAO interface
public class StudentService implements StudentDao {
    private final DatabaseConnection dbc;

    public StudentService(DatabaseConnection dbc) {

        this.dbc = dbc;
    }

    public StudentService() {
        this(DatabaseConnection.MANAGEMENT_SYSTEM);  //UAT);
    }

    /**
     * reads the student table in database
     * @return database data as a List<Student>
     */
    @Override
    public List<StudentInterface> getAllStudents() {
        ResultSet resultSet = dbc.executeQuery("SELECT * FROM students");
        try {

 //           return null; // TODO - Parse `List<StudentInterface>` from `resultSet`
            List<StudentInterface> studentInterfaceList = new ArrayList<>();
            while(resultSet.next()) {
                Student student = new Student();
                student.setEmail(resultSet.getString("email"));
                student.setName(resultSet.getString("name"));
                student.setPassword(resultSet.getString("password"));
                studentInterfaceList.add(student);
            }
            return studentInterfaceList;
        } catch(Exception e) {
            throw new Error(e);
        }
    }

    /**
     * takes a Student’s email as a String and parses the student list for a Student with that email and returns a Student Object.
     * @param studentEmail - student's email to be parsed
     * @return the student list of a Student with respective `studentEmail`
     */
    @Override
    public StudentInterface getStudentByEmail(String studentEmail) {
//        return null;
        return getAllStudents()
                .stream()
                .filter(student -> student.getEmail().equals(studentEmail))
                .findFirst()
                .get();
    }

    /**
     * This method takes two parameters: the first one is the user email and the second one is the password from the user input.
     * @param studentEmail - email student uses to log in
     * @param password - password student uses to log in
     * @return `true` if a student was found; else `false`
     */
    @Override
    public Boolean validateStudent(String studentEmail, String password) {
 //       return null;

    //   if I get the student by email and verify the password then return true else false

 //      if(getAllStudents().contains(getStudentByEmail(studentEmail)) && getStudentByEmail(studentEmail).getPassword().equals(password)) {
        try {
            if (getStudentByEmail(studentEmail) != null && getStudentByEmail(studentEmail).getPassword().equals(password)) {
                return true;
            } else {
                return false;
            }
        }catch(Exception e){
            return false;
        }
      //  return false;
 //       Predicate<StudentInterface> p1 = student -> student.getEmail().equalsIgnoreCase(studentEmail) && student.getPassword().equals(password);
     //  boolean b1 = list.stream().allMatch(p1);
 //       return getAllStudents()
 //               .stream()
 //                 .allMatch(p1)
          /*.filter(student -> student.getEmail().equalsIgnoreCase(studentEmail) && student.getPassword().equals(password))
   //             .forEach(student -> (student.getEmail().equalsIgnoreCase(studentEmail) && student.getPassword().equals(password)))

                    {
                        return true;
                        //Assert.assertEquals(1L, 1L);
                    }else{
                       return false;
                       //Assert.assertEquals(1L, 2L);
                    }
           */

        //        .allMatch(student -> student.getEmail().equalsIgnoreCase(studentEmail) && student.getPassword().equals(password))
 //               .allMatch(student)
  //              ;

    }

    /**
     * After a successful student validation, this method takes a Student’s email and a Course ID.
     * It checks in the join table (i.e. Student_Course) generated by JPA to find if a Student with that Email is currently attending a Course with that ID.
     * If the Student is not attending that Course, register the student to that course; otherwise not
     * @param studentEmail - email student uses to log in
     * @param courseId - id of course student wishes to register to
     */
    @Override///////-------------------
    public void registerStudentToCourse(String studentEmail, int courseId) {
        //getStudentCourse() with studentEmail to find out if they are already registered
        ///////////////////////////////////////////////////////////////////////////////////////////******
        ResultSet resultSet = dbc.executeQuery("SELECT * FROM students");
        try {

///////BUILD BELOW FIRST, SO THAT YOU CAN USE IT TO SOLVE THIS PROBLEM.....
        } catch(Exception e){  ////
        }

    }

    /**
     * This method takes a Student’s Email as a parameter and would find all the courses a student is registered.
     * @param studentEmail - student's email to be parsed
     * @return list of courses student has registered to
     */
    @Override//*******//**********///***************//******************//********************//
    public List<CourseInterface> getStudentCourses(String studentEmail) {
/*
        List<CourseInterface> studentCoursesList = new ArrayList<>();
        ResultSet resultSet = dbc.executeQuery("SELECT * FROM Student_Course WHERE 'email' = studentEmail");
 //       try {
            return getAllStudents()
                    .stream()
                    .filter(student -> student.getEmail().equals(studentEmail))
                    .findFirst()
 //                   .collect(Collections.toList());
                    .get();

  //          return resultSet;
        } */
        return null;
    }


}
